1、使用redis做分布式锁时，若加入了@Transactional(rollbackFor = Exception.class)注解，则会发生两个线程读取
数据库表数据不一致的情况。
如：当第一个线程对表进行库减操作 从7变为5，然后释放锁
    第二个线程进入，再次读取表数据，结果还为7，导致读取的数据不一样。
    
    可能原因就是：mysql数据库的事务默认为【可重复读】
    【Spring事务的原因】

2、集群时数据库读写会不会不一致。
3、@Transactional(rollbackFor = Exception.class)与synchronized加在一起出现数据不一致的情况    
- 问题分析
  上面这个例子是无法保证数据的一致性.由于spring的aop，会在update方法之前开启事务，之后再加锁，当锁住的代码执行完成后，再提交事务，因此锁住的代码块执行是在事务之内执行的，可以推断在代码块执行完时，事务还未提交，锁已经被释放，此时其他线程拿到锁之后进行锁住的代码块，读取的库存数据不是最新的。
- 解决方法
  我们可以在@Transactional方法之前就加上锁，在还没有开事务之前就加锁，那么就可以保证线程的安全性，从而不会出现脏读和数据不一致性等情况.  